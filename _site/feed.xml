<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>崔仪洁的博客</title>
    <description>崔仪洁的博客，记录生活的点点滴滴。所谓青春已逝，大概就是当风雨来时，抬头一看，已无屋檐。低头一看，自己已成屋檐的时候吧。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 02 Nov 2019 02:39:59 +0800</pubDate>
    <lastBuildDate>Sat, 02 Nov 2019 02:39:59 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>在CentOS7上使用Docker和Haproxy部署Emq集群</title>
        <description>&lt;h2 id=&quot;1安装docker&quot;&gt;1.安装Docker&lt;/h2&gt;
&lt;p&gt;由于yum默认是没有Docker源的，所以安装之前需要先安装Docker源，这一步参照&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/ubuntu/&quot;&gt;官方安装文档&lt;/a&gt;，直接复制黏贴代码即可。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# update yum package index（更新yum索引）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum update
&lt;span class=&quot;c&quot;&gt;# Install packages to allow yum to install docker（安装相关工具）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; yum-utils &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  device-mapper-persistent-data &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  lvm2
&lt;span class=&quot;c&quot;&gt;# set up the stable repository（安装docker stable源）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum-config-manager &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;--add-repo&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    https://download.docker.com/linux/centos/docker-ce.repo
&lt;span class=&quot;c&quot;&gt;# update yum package index（安装了新的源，所以再次更新索引）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum update
&lt;span class=&quot;c&quot;&gt;#Install the latest version of Docker CE（这里安装最新的Docker CE版本）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-ce
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;朝上面在安装Docker源的那一步在天朝需要&lt;strong&gt;科学上网&lt;/strong&gt;，&lt;strong&gt;科学上网&lt;/strong&gt;，&lt;strong&gt;科学上网&lt;/strong&gt;，说三遍。一番操作之后Docker应该是安装完成了，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker version&lt;/code&gt;命令，没有报错则安装成功。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@localhost ~]# docker version
Client:
 Version:           18.09.1
 API version:       1.39
 Go version:        go1.10.6
 Git commit:        4c52b90
 Built:             Wed Jan  9 19:35:01 2019
 OS/Arch:           linux/amd64
 Experimental:      &lt;span class=&quot;nb&quot;&gt;false
&lt;/span&gt;Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl start docker&lt;/code&gt;命令即可启动Docker。&lt;/p&gt;

&lt;h2 id=&quot;2使用docker启动两个emqttd容器&quot;&gt;2.使用Docker启动两个emqttd容器&lt;/h2&gt;
&lt;p&gt;这里我在Docker hub（需要科学上网）找到了一个别人已经构建好的镜像&lt;a href=&quot;https://hub.docker.com/r/tldzyx/emqttd&quot;&gt;tldzyx/emqttd&lt;/a&gt;（访问需要科学上网）。
我们拉下来只有后分别启动&lt;code class=&quot;highlighter-rouge&quot;&gt;emq1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;emq2&lt;/code&gt;的容器。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 下载镜像&lt;/span&gt;
docker pull tldzyx/emqttd
&lt;span class=&quot;c&quot;&gt;# 启动emq1节点($emqttd_img是刚才pull的emqttd镜像的ID，通过docker images查看)&lt;/span&gt;
docker run &lt;span class=&quot;nt&quot;&gt;-tid&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; emq1 &lt;span class=&quot;nv&quot;&gt;$emqttd_img&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 启动emq2节点&lt;/span&gt;
docker run &lt;span class=&quot;nt&quot;&gt;-tid&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; emq2 &lt;span class=&quot;nv&quot;&gt;$emqttd_img&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样的话我们在docker中已经启动了两个emq节点，现在我们需要讲两个节点连接起来。
首先我们先进入节点emq1中，查看emq1节点的地址。
使用一下命令&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 进入emq1节点中，相当于ssh登录到到了emq1虚拟机上&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; emq1 sh 
&lt;span class=&quot;c&quot;&gt;# 查看节点地址&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;emqttd_ctl status
&lt;span class=&quot;c&quot;&gt;# /opt/emqttd $ emqttd_ctl status&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Node '579193a0262d@172.17.0.2' is started&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# emqttd 2.3.8 is running&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 退出&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到emq1节点的地址是&lt;code class=&quot;highlighter-rouge&quot;&gt;579193a0262d@172.17.0.2&lt;/code&gt;，紧接着我们进入第二个节点emq2中，&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 登录emq2&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; emq2 sh
&lt;span class=&quot;c&quot;&gt;# 寻找emq1，是emq1加入集群&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;emqttd_ctl cluster &lt;span class=&quot;nb&quot;&gt;join &lt;/span&gt;579193a0262d@172.17.0.2
&lt;span class=&quot;c&quot;&gt;# 验证是否成功&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;emqttd_ctl cluster status
&lt;span class=&quot;c&quot;&gt;# Cluster status: [{running_nodes,['a5ac028fba1e@172.17.0.3',&lt;/span&gt;
                                 &lt;span class=&quot;s1&quot;&gt;'579193a0262d@172.17.0.2'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显而易见我们已经将两个节点加入到同一个集群中了。&lt;/p&gt;

&lt;h2 id=&quot;3使用haproxy负载均衡两个节点&quot;&gt;3.使用Haproxy负载均衡两个节点&lt;/h2&gt;
&lt;p&gt;首先我们安装Haproxy&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; haproxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;紧接着我们使用利用这个拉取的镜像去构建一个我们自己的镜像。&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;emqtt-haproxy-docker
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;emqtt-haproxy-docker
&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;haproxy.cfg
&lt;span class=&quot;c&quot;&gt;# 修改haproxy.cfg内容如下(将IP地址改成emq1,emq2的ip地址)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 一些默认参数&lt;/span&gt;
defaults
  log                     global
  option                  dontlognull
  option http-server-close
  retries                 3
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;http-request    10s
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;queue           1m
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;connect         10s
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;client          1m
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;server          1m
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;http-keep-alive 10s
  &lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;check           10s
&lt;span class=&quot;c&quot;&gt;# 负载均衡mqtt的tcp接口&lt;/span&gt;
frontend emqtt-front
  &lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;:1883
  mode tcp
  default_backend emqtt-backend

backend emqtt-backend
   balance roundrobin
   server emq1 172.17.0.2:1883 check
   server emq2 172.17.0.2:1883 check
&lt;span class=&quot;c&quot;&gt;# 负载均衡mqtt的http管理员界面&lt;/span&gt;
frontend emqtt-admin-front
  &lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;:18083
  mode http
  default_backend emqtt-admin-backend

backend emqtt-admin-backend
  mode http
  balance roundrobin
  server emq1 172.17.0.2:18083 check
  server emq2 172.17.0.3:18083 check
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;接下来我们使用一个Dockerfile来构建&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;Dockerfile

&lt;span class=&quot;c&quot;&gt;# 修改Dockerfile内容如下：&lt;/span&gt;
FROM haproxy:latest &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Dockerfile
COPY haproxy.cfg /usr/local/etc/haproxy/haproxy.cfg &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; Dockerfile

&lt;span class=&quot;c&quot;&gt;# 使用下面的命令构建新的镜像&lt;/span&gt;
docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; emqtt-haproxy &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker ps&lt;/code&gt;可以查看到我们刚才构建好的镜像,即&lt;code class=&quot;highlighter-rouge&quot;&gt;emqtt-haproxy&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@localhost ~]# docker  images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
emqtt-haproxy       latest              249538bcbccb        12 hours ago        72MB
haproxy             latest              d23194a3929a        4 days ago          72MB
mytomcat            latest              685e1c839eac        2 months ago        720MB
sebp/elk            latest              2fbf0a30426d        2 months ago        1.45GB
centos              7                   75835a67d134        3 months ago        200MB
tldzyx/emqttd       latest              6e7f1fc919fb        8 months ago        78.9MB
boldt/coturn        latest              2c927afe2958        17 months ago       189MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;下面来尝试启动代理服务器来负载均衡两个节点&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; haproxy-syntax-check emqtt-haproxy haproxy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /usr/local/etc/haproxy/haproxy.cfg

&lt;span class=&quot;c&quot;&gt;# 请指定端口映射1833是tcp服务，18083是管理员界面dashboard&lt;/span&gt;
docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; emqtt-running-haproxy &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 1883:1883 &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 18083:18083 emqtt-haproxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大功告成，在浏览器中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://your-server-ip:18083&lt;/code&gt; ，登陆后即可查看emq集群的运行状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/2019-01-13-emq-node.png&quot; alt=&quot;emq_node&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Jan 2019 06:51:49 +0800</pubDate>
        <link>http://localhost:4000/2019/01/14/centos-install-emqttd-cluster.html</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/14/centos-install-emqttd-cluster.html</guid>
        
        <category>Emq</category>
        
        
      </item>
    
      <item>
        <title>macOS调整LaunchPad图标大小</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;macOS的Launchpad默认图标很大，看起来很不美观，下面是调整图标大小的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;打开终端输入一下命令&quot;&gt;打开终端输入一下命令&lt;/h2&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 调整每列显示图标个数&lt;/span&gt;
defaults write com.apple.dock springboard-rows &lt;span class=&quot;nt&quot;&gt;-int&lt;/span&gt; 7

&lt;span class=&quot;c&quot;&gt;# 调整每行显示图表个数&lt;/span&gt;
defaults write com.apple.dock springboard-columns &lt;span class=&quot;nt&quot;&gt;-int&lt;/span&gt; 8

&lt;span class=&quot;c&quot;&gt;# 重启&lt;/span&gt;
defaults write com.apple.dock ResetLaunchPad &lt;span class=&quot;nt&quot;&gt;-bool&lt;/span&gt; TRUE
killall Dock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;调整之后的效果图&quot;&gt;调整之后的效果图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/2018-11-20-lunchpad.jpeg&quot; alt=&quot;2018-11-20-lunchpad&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Nov 2018 20:30:30 +0800</pubDate>
        <link>http://localhost:4000/2018/11/20/change-mac-lunchpad.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/20/change-mac-lunchpad.html</guid>
        
        <category>Tools</category>
        
        
      </item>
    
      <item>
        <title>分享一些自己做菜</title>
        <description>&lt;h2 id=&quot;喜欢做菜&quot;&gt;喜欢做菜&lt;/h2&gt;
&lt;p&gt;民以食为天，程序员毫不例外，为了讨好自己的胃，在空闲的时候总想给自己做点好吃的。这个文章就记录一下自己做的“大餐”吧。&lt;/p&gt;

&lt;h3 id=&quot;20181110-中午&quot;&gt;2018.11.10 中午&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/food/2018-11-10-l.jpg&quot; alt=&quot;2018-11-10-l&quot; /&gt;&lt;/p&gt;
&lt;center&gt;洋葱炒肉丝（肉丝有点粗），搭配阿萨姆奶茶&lt;/center&gt;

&lt;h3 id=&quot;20181110-晚上&quot;&gt;2018.11.10 晚上&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/food/2018-11-10-d.jpg&quot; alt=&quot;2018-11-13-d&quot; /&gt;&lt;/p&gt;
&lt;center&gt;老母鸡汤，去掉了菊花（羞~(@^_^@)~），人到中年，枸杞必备&lt;/center&gt;

&lt;h3 id=&quot;20181113-晚上&quot;&gt;2018.11.13 晚上&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/food/2018-11-13-d.jpg&quot; alt=&quot;2018-11-13-d&quot; /&gt;&lt;/p&gt;
&lt;center&gt;毛豆炒肉粒吧（切不好肉丝），搭配老干妈，爽&lt;/center&gt;

&lt;h3 id=&quot;20181114-晚上&quot;&gt;2018.11.14 晚上&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/food/2018-11-14-d.jpg&quot; alt=&quot;2018-11-14-d&quot; /&gt;&lt;/p&gt;
&lt;center&gt;加班回来，做了个火锅料方便面(╥╯^╰╥)&lt;/center&gt;

&lt;h3 id=&quot;20181117-晚上&quot;&gt;2018.11.17 晚上&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/food/2018-11-17-d.jpg&quot; alt=&quot;2018-11-17-d&quot; /&gt;&lt;/p&gt;
&lt;center&gt;白菜炒菠菜，青椒炒培根火腿&lt;/center&gt;
</description>
        <pubDate>Sun, 18 Nov 2018 07:58:49 +0800</pubDate>
        <link>http://localhost:4000/2018/11/18/food-share.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/18/food-share.html</guid>
        
        <category>Life</category>
        
        
      </item>
    
      <item>
        <title>Centos7安装WebRtc打洞服务器Coturn方法</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在使用WebRtc时，我们需要打洞服务器来打洞两部设备之间的通信，这里我们采用Coturn库。由于Turn服务器是Stun的一个拓展，Coturn包括了Turn和Stun，所有我们只需要部署Coturn就可以完成WebRtc的打洞环节啦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;克隆并安装&quot;&gt;克隆并安装&lt;/h2&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/coturn/coturn 
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;coturn 
./configure 
make 
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果你的电脑上没有安装LibEvent2，需要先安装&lt;code class=&quot;highlighter-rouge&quot;&gt;libevent-devel&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Install the libevent-devel rpm package:&lt;/span&gt;
yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libevent-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;安装好之后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;which turnserver&lt;/code&gt;确保安装成功&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;root@localhost &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# which turnserver&lt;/span&gt;
/usr/local/bin/turnserver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;设置配置文件&quot;&gt;设置配置文件&lt;/h2&gt;
&lt;p&gt;在Coturn编译完成好之后会自动生成一个配置文件的模板，在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/etc/turnserver.conf.default&lt;/code&gt;，感兴趣的小伙伴可以仔细查看里面每一个配置项的含义。这里我们在新建一个新的配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/etc/turnserver.conf&lt;/code&gt;，在这个里面编辑好之后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;turnserver&lt;/code&gt;命令会自动寻找到conf文件的位置。分享一个简单的配置文件的格式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;relay-device=enp1s0f0  //绑定的网卡的设备号
listening-ip=x.x.x.x //内网IP，阿里云腾讯云的机器一般是内网的IP，没有填外网IP也可以
listening-port=3478 
relay-ip=x.x.x.x  //外网IP，就是外网访问本台服务器的IP地址，这个就是提供给webrtc客户端来传递数据的IP
external-ip=x.x.x.x  //外网IP
relay-threads=500 
lt-cred-mech    //这个要填上，否则不支持webrtc
pidfile=&quot;/var/run/turnserver.pid&quot; 
min-port=49152  //虚拟给客户端的端口号，min-max的范围选取要能支撑起你的服务，要不然会出现转发服务器不够用的情况
max-port=65535 
user=xxx:123456     //xxx会用户名，123456是密码
realm=AnHui
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;保存好之后使用命令&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;turnserver &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;即可启动Coturn。&lt;/p&gt;
&lt;h2 id=&quot;验证coturn的可用性&quot;&gt;验证Coturn的可用性&lt;/h2&gt;
&lt;p&gt;有一个专门的网站可以检查打洞服务器的正确配置与否。
&lt;a href=&quot;https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/&quot;&gt;Trickle ICE&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证stun&quot;&gt;验证stun&lt;/h3&gt;
&lt;p&gt;输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;stun:x.x.x.x:3478&lt;/code&gt;
得到结果&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Time	Component	Type	Foundation	Protocol	Address	Port	Priority
0.002	1	host	886443856	udp	10.80.1.131	49469	126 | 32542 | 255
0.104	1	host	2052453280	tcp	10.80.1.131	9	90 | 32542 | 255
0.288	1	srflx	2643034245	udp	112.27.203.124	49469	100 | 32542 | 255
0.312	Done
0.313
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;看到&lt;code class=&quot;highlighter-rouge&quot;&gt;srflx&lt;/code&gt;后面就是你的电脑的外网IP，表示打洞成功。&lt;/p&gt;
&lt;h3 id=&quot;验证turn&quot;&gt;验证turn&lt;/h3&gt;
&lt;p&gt;输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;turn:x.x.x.x:3478&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;username:&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt;
得到结果&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0.003	1	host	886443856	udp	10.80.1.131	55831	126 | 32542 | 255
0.104	1	host	2052453280	tcp	10.80.1.131	9	90 | 32542 | 255
0.534	1	srflx	2643034245	udp	112.27.203.124	55831	100 | 32542 | 255
0.614	1	relay	3676437432	udp	x.x.x.x	56631	2 | 32542 | 255
0.878	Done
0.880
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;看到&lt;code class=&quot;highlighter-rouge&quot;&gt;relay&lt;/code&gt;后面就是你的服务器的外网IP，表示可以使用Coturn的turn服务器进行转发。同时也可以看见srflx，这说明了turn服务是stun的一个拓展，turn和stun是包含的关系。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Coturn的部署就简单的介绍到这里，如有不对的地方，还望指正，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 14 Oct 2018 06:21:49 +0800</pubDate>
        <link>http://localhost:4000/2018/10/14/cenos7-install-coturn.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/14/cenos7-install-coturn.html</guid>
        
        <category>WebRtc</category>
        
        
      </item>
    
      <item>
        <title>Scala常用算子学习</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Scala&lt;/code&gt;中很多的集合操作符，学会了他们在平时的编程中可以节约很多的时间。这其中的一些操作和&lt;code class=&quot;highlighter-rouge&quot;&gt;RxJava&lt;/code&gt;中的一些操作符十分相似。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1foreach&quot;&gt;1.foreach&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;可以直接遍历一个集合中的所有元素，没有返回值。
栗子：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//先定义个List
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
输出结果
a
b
c
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2map&quot;&gt;2.map&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;的功能有点和&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;相似，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;有返回值，他可以将一个集合中的元素逐一取出，在处理过后再重新组合成原来集合的类型并返回。
举个栗子：&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//先定义个List
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toUpperCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//打印出结果 List(A, B, C)
//可见map将函数中的每个字母取出去进行大小写转换，然后又重新组合成原有的数据类型List集合并返回。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3flatten&quot;&gt;3.flatten&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatten&lt;/code&gt;的作用是讲一个嵌套的结构展开。
话不多说，老板来个栗子！&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//我们分别定义了List,Set,Map集合，将其嵌套在一个List中，在使用flatten函数将其展开
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aNames&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bNames&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cNames&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dn&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatten&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//打印结果
//List(a, b, c, d, (d,dn), (e,en))
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4zip&quot;&gt;4.zip&lt;/h2&gt;
&lt;p&gt;看到&lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;心里想着这货不是压缩包的后缀嘛，顾名思义就是讲两个集合打包，就是合并起来的意思，这个的合并是指每个对应的元素合并起来，形成一个包含两个元素的新元素，可能有点难理解，直接看栗子。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'a,'b,'c,'d)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//打印结果
//List(('a,1), ('b,2), ('c,3), ('d,4))
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;5zipwithindex&quot;&gt;5.zipWithIndex&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zipWithIndex&lt;/code&gt;是指和&lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;有些类似，是讲一个列表遍历出来，与当前元素在集合中的位置（即Index）合并在一起，形成一个新的元素。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zipWithIndex&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//打印结果
//List((2,0), (3,1), (4,2), (5,3))
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;6flatmap&quot;&gt;6.flatmap&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatmap&lt;/code&gt;函数的功能是&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;flatten&lt;/code&gt;的结合体，先将嵌套的结构，接收一个可以处理嵌套列表的函数（我的理解是这个函数需要有返回值，例如前面介绍的&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;），返回一个经过处理的原类型的集合。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//这里我将两个List嵌套起来，然后先经过flatMap取到x（x即为names中嵌套的集合：aNames和bNames），然后经过map函数，遍历拿到的x集合，将其转换为大写字母，返回给flatMap函数，进行合并。
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aNames&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bNames&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;d&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bNames&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&amp;gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toUpperCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//打印结果如下
//List(A, B, C, D)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;7filter&quot;&gt;7.filter&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;顾名思义就是过滤器的意思，接收一个返回Boolean的函数，true和保留，false过滤掉。&lt;/p&gt;
&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//我们定义了一个几个，filter函数中返回的是各个元素是否为偶数，是偶数返回true，则保留，反之过滤。
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ages&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}))&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//打印结果
//List(2, 4, 6)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;以上是我暂时总结的7种集合操作符，理解之后灵活运用可以节省很多时间，但是这些函数的使用都需要有lambda表达式的基础，今天写到这里，如果你发现了一些错误还望海涵，并严厉指出，不胜感激！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 02 Oct 2018 06:21:49 +0800</pubDate>
        <link>http://localhost:4000/2018/10/02/scala-learning.html</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/02/scala-learning.html</guid>
        
        <category>Scala</category>
        
        
      </item>
    
  </channel>
</rss>
